# This GitHub Actions workflow automates the entire CI/CD process for a .NET solution
# that contains both a .NET Framework and .NET projects.
#
# Workflow Steps:
# 1. Test: Runs unit tests for the solution.
# 2. Version: Automatically increments the version number and creates a new git tag.
# 3. Detect & Build: Detects the project types by using Target Framework from csproj files (.NET Framework vs .NET)
#    and builds them separately using the appropriate tools (MSBuild or dotnet CLI).
# 4. Deploy Release:
#    - Moved release asset into Plugin folder to separate SAL Host and release assets.
#    - Downloads latest release assets from a corresponding "Flatbed.Dialog.Lite" version repository.
#    - Merges the downloaded assets into the build output.
#    - Creates two separate zip archives for each framework type.
#    - Publishes a single GitHub Release containing both zip files.
# 5. Deploy NuGet: Publishes a NuGet package to GitHub Packages.
# 6. Cleanup: If any build or deploy step fails, it automatically removes the created git tag.

name: Test, Buid, Release

on:
  push:
    branches: [ "master" ]
  workflow_dispatch:

env:
  SolutionName: ${{github.event.repository.name}}
  NuGetPackageSourceCredentials_github_DKorablin: Username=${{github.actor}};Password=${{secrets.DEPLOYMENT_TOKEN}}
  DotNetVersion: 8.0.x

defaults:
  run:
    shell: pwsh

jobs:
  test_net_windows:
    name: Testing .NET (Windows)
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: true
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{env.DotNetVersion}}
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        # Create a new cache when packages.lock.json changes
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
        # If the exact key doesn't exist, use the most recent cache for this OS
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restoring dependencies
      run: dotnet restore ${{env.SolutionName}}.sln
    - name: Testing .NET
      run: dotnet test ${{env.SolutionName}}.sln --no-build --verbosity normal

  version:
    name: Incrementing version number
    needs: [test_net_windows]
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{steps.tag_version.outputs.new_version}}
      new_tag: ${{steps.tag_version.outputs.new_tag}}
      changelog: ${{steps.tag_version.outputs.changelog}}
    steps:
    - name: Updating version number
      id: tag_version
      uses: mathieudutour/github-tag-action@v6.2
      with:
        github_token: ${{secrets.GITHUB_TOKEN}}
        #custom_tag: 1.0.0

  build_net:
    name: Build
    needs: [version]
    runs-on: windows-latest
    steps:
    - name: Decoding strong-name key
      id: sign_key_file
      uses: timheuer/base64-to-file@v1.2
      with:
        fileName: 'Signature.snk'
        encodedString: ${{secrets.SIGN_ASM_KEY}}
    - uses: actions/checkout@v4
 
      with:
        dotnet-version: ${{env.DotNetVersion}}
    - name: Caching NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
    - name: Restore
      run: msbuild ${{env.SolutionName}}.sln /t:Restore
    - name: Build multi-target project
      run: >
        msbuild ${{env.SolutionName}}.sln
        /p:Configuration=Release
        /p:ArtifactsDir="${{github.workspace}}\bin"
        /p:GenerateDocumentationFile=true
        /p:SignAssembly=true
        /p:Version=${{needs.version.outputs.new_version}}
        /p:AssemblyOriginatorKeyFile="${{steps.sign_key_file.outputs.filePath}}"
    - name: Listing output directory
      run: |
        echo "Listing files in the release directory:"
        ls ${{github.workspace}}\bin -Recurse
    - name: Finding portable executables to sign
      id: find_binaries
      run: |
        $filePaths = Get-ChildItem -Path "${{github.workspace}}\bin" -Recurse -Include "${{ env.SolutionName }}.dll" | ForEach-Object { $_.FullName }
        $multiLineString = $filePaths -join "`n"

        echo "Found files to sign:"
        echo $multiLineString

        echo "files_to_sign<<EOF" >> $env:GITHUB_OUTPUT
        echo $multiLineString >> $env:GITHUB_OUTPUT
        echo "EOF" >> $env:GITHUB_OUTPUT
    - name: Signing portable executables
      uses: dlemstra/code-sign-action@v1
      with:
        certificate: '${{secrets.SIGN_PE_CERTIFICATE}}'
        password: '${{secrets.SIGN_PE_PASSWORD}}'
        recursive: false
        files: ${{steps.find_binaries.outputs.files_to_sign}}
    - name: Organize Artifacts into Plugin subfolders
      # This step creates a "Plugin" folder inside each artifact directory and moves all content into it.
      run: |
        Set-Location -Path "${{github.workspace}}/bin"
        $frameworkDirs = Get-ChildItem -Directory

        # Loop through each framework directory
        foreach ($dir in $frameworkDirs) {
          Write-Host "Processing directory: $($dir.Name)"

          # 1. Create the new 'Plugin' subfolder
          $pluginFolderPath = Join-Path -Path $dir.FullName -ChildPath "Plugin"
          New-Item -ItemType Directory -Path $pluginFolderPath

          # 2. Get all items (including hidden files) inside the framework folder
          $itemsToMove = Get-ChildItem -Path $dir.FullName -Force

          # 3. Move each item into the new 'Plugin' folder
          foreach ($item in $itemsToMove) {
            # Make sure not to move the 'Plugin' folder into itself
            if ($item.Name -ne "Plugin") {
              Move-Item -Path $item.FullName -Destination $pluginFolderPath
            }
          }
        }
    # This step query the latest version of SAL Flatbed application to store executable files inside current release
    - name: Get latest Flatbed.Dialog.Lite release version
      id: get_flatbed_release
      run: |
        $headers = @{
          "Authorization" = "token ${{ secrets.DEPLOYMENT_TOKEN }}"
          "Accept"        = "application/vnd.github.v3+json"
        }
        $apiUrl = "https://api.github.com/repos/DKorablin/Flatbed.Dialog.Lite/releases/latest"

        try {
          # Invoke-RestMethod automatically parses the JSON response into an object
          $response = Invoke-RestMethod -Uri $apiUrl -Headers $headers
          $latestVersion = $response.tag_name

          if ([string]::IsNullOrEmpty($latestVersion)) {
            Write-Error "Error: The latest release for DKorablin/Flatbed.Dialog.Lite does not have a valid tag name."
            exit 1
          } else {
            echo "latest_version=$latestVersion" >> $env:GITHUB_OUTPUT
            Write-Host "Successfully found latest version: $latestVersion"
          }
        } catch {
          # This block will catch API errors (like 404 Not Found) or network issues
          Write-Error "An error occurred while fetching the release information: $_"
          exit 1
        }
    - name: Downloading Flatbed.Dialog.Lite latest versions
      uses: dsaltares/fetch-gh-release-asset@master
      with:
        repo: DKorablin/Flatbed.Dialog.Lite
        regex: true
        file: Flatbed.Dialog.Lite.*.zip
        target: ${{github.workspace}}\bin
        token: ${{secrets.DEPLOYMENT_TOKEN}}
    - name: Listing output directory
      run: |
        echo "Listing files in the release directory:"
        ls ${{github.workspace}}\bin -Recurse
    # After that we need to extract all files related to SAL executable into bin folder for specific build
    - name: Dynamically extract assets into framework folders
      shell: bash
      run: |
        # Get all the framework-specific subdirectories in the bin folder
        $frameworkDirs = Get-ChildItem -Path "${{github.workspace}}/bin" -Directory

        # Loop through each framework directory
        foreach ($dir in $frameworkDirs) {
          $frameworkName = $dir.Name
          Write-Host "----- Processing framework: $frameworkName -----"

          # Construct the expected asset filename and its full path
          $assetFilename = "Flatbed.Dialog.Lite_${{steps.get_flatbed_release.outputs.latest_version}}_${frameworkName}.zip"
          $assetFilePath = Join-Path -Path "${{github.workspace}}" -ChildPath $assetFilename

          Write-Host "Looking for asset file: $assetFilePath"

          # Check if the corresponding zip file was downloaded
          if (Test-Path -Path $assetFilePath -PathType Leaf) {
            Write-Host "Asset found. Extracting to '$($dir.FullName)'..."

            # Unzip the asset into its corresponding framework folder, overwriting if necessary
            Expand-Archive -Path $assetFilePath -DestinationPath $dir.FullName -Force

            Write-Host "Cleaning up downloaded zip file..."
            Remove-Item -Path $assetFilePath
          }
          else {
            # Output a warning that GitHub Actions will highlight in the logs
            Write-Warning "Asset file '$assetFilename' not found. Skipping extraction for this framework."
          }

          Write-Host "----- Finished processing framework: $frameworkName -----"
        }
    # After SAL executables are also packed inside bin folder we need to pack all of them into separate release assets
    - name: Zipping individual artifacts
      run: |
        # Get all the framework-specific subdirectories in the bin folder
        $frameworkDirs = Get-ChildItem -Path "${{github.workspace}}/bin" -Directory

        # Loop through each framework directory to create a zip file from its contents
        foreach ($dir in $frameworkDirs) {
          $dirName = $dir.Name
          Write-Host "Zipping contents of directory: $dirName"

          # Construct the name for the output zip file
          $zipFileName = "${{env.SolutionName}}_v${{needs.version.outputs.new_version}}_${dirName}.zip"
      
          # The destination for the zip file is the parent 'bin' directory
          $destinationPath = Join-Path -Path $dir.Parent.FullName -ChildPath $zipFileName

          # The source path is all content (*) inside the directory. This ensures
          # the parent folder itself isn't included in the zip, matching the original script's behavior.
          $sourceContentPath = Join-Path -Path $dir.FullName -ChildPath "*"

          # Create the zip archive, overwriting if it already exists
          Compress-Archive -Path $sourceContentPath -DestinationPath $destinationPath -Force
        }
      working-directory: ${{github.workspace}}/bin
    - name: Deploying GitHub release
      uses: ncipollo/release-action@v1
      with:
        # Creating deployment release with from all packed zip files
        artifacts: ${{github.workspace}}/bin/*.zip
        tag: ${{needs.version.outputs.new_tag}}
        name: Auto ${{needs.version.outputs.new_tag}}
        body: ${{needs.version.outputs.changelog}}
        artifactErrorsFailBuild: true
        generateReleaseNotes: true
        token: ${{secrets.DEPLOYMENT_TOKEN}}
    - name: Creating NuGet package
      run: >
        dotnet pack ${{ env.SolutionName }}.sln --no-build --no-restore -o ${{github.workspace}}\bin\nupkg
        /p:ArtifactsDir="${{github.workspace}}\bin"
        /p:PackageVersion=${{needs.version.outputs.new_version}}
        /p:IncludeSymbols=true
        /p:DebugType=Portable
        /p:EmbedUntrackedSources=true
        /p:PublishRepositoryUrl=true
        /p:SymbolPackageFormat=snupkg
    - name: Deploying package to GitHub
      run: dotnet nuget push ${{github.workspace}}\bin\nupkg\ --skip-duplicate --api-key ${{secrets.GITHUB_TOKEN}} --source https://nuget.pkg.github.com/DKorablin/index.json

  failure_cleanup:
    name: Remove version tag on failure
    needs: [version, build_net]
    if: always() && needs.build_net.result != 'success'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: false
        fetch-depth: 0 #Fetch all history for all tags and branches
    - name: Removing version tag
      run: |
        git tag -d ${{needs.version.outputs.new_tag}} || true
        git push origin :refs/tags/${{needs.version.outputs.new_tag}} || true