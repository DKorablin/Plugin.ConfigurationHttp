# This GitHub Actions workflow automates the CI/CD process for all SAL plugins.
#
# Workflow Steps:
# 1. Test: Runs all unit tests for the solution.
# 2. Version: Automatically increments the version number based on commit history and creates a new Git tag.
# 3. Build, Package, and Release: This is a multi-stage job that performs the following:
#    - Builds the multi-targeted project for all target frameworks.
#    - Signs the output assemblies.
#    - Creates and publishes a NuGet package to GitHub Packages.
#    - Organizes build artifacts into a 'Plugin' subfolder structure.
#    - Calls an external PowerShell script to download required release assets from the 'Flatbed.Dialog.Lite' repository,
#      matching only the frameworks that were just built.
#    - Organize build artifacts, injects dependencies, and creates the final zipped release archives for each target framework.
#    - Publishes a single, comprehensive GitHub Release with all generated .zip files as artifacts.
# 4. Cleanup: If any part of the build or release process fails, a final job runs to remove the Git tag that was created.

name: Test, Buid, Release

on:
  push:
    branches: [ "master" ]
  workflow_dispatch:
    inputs:
      dotNetVersion:
        description: 'Determine the version of .NET used to configure the environment'
        required: false
        default: '8.0.x'
      newVersion:
        description: 'Optionally specify a new version number (overrides automatic versioning)'
        required: false
        default: ''

env:
  SolutionName: ${{github.event.repository.name}}
  NuGetPackageSourceCredentials_github_DKorablin: Username=${{github.actor}};Password=${{secrets.DEPLOYMENT_TOKEN}}
  DotNetVersion: ${{github.event.inputs.dotNetVersion || '8.0.x'}}

defaults:
  run:
    shell: pwsh

jobs:
  test_net_windows:
    name: Testing .NET (Windows)
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: true
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{env.DotNetVersion}}
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        # Create a new cache when packages.lock.json changes
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
        # If the exact key doesn't exist, use the most recent cache for this OS
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restoring dependencies
      run: dotnet restore ${{env.SolutionName}}.sln
    - name: Testing .NET
      run: dotnet test ${{env.SolutionName}}.sln --no-build --verbosity normal

  version:
    name: Incrementing version number
    needs: [test_net_windows]
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{steps.tag_version.outputs.new_version}}
      new_tag: ${{steps.tag_version.outputs.new_tag}}
      changelog: ${{steps.tag_version.outputs.changelog}}
    steps:
    - name: Updating version number
      id: tag_version
      uses: mathieudutour/github-tag-action@v6.2
      with:
        github_token: ${{secrets.GITHUB_TOKEN}}
        custom_tag: ${{github.event.inputs.newVersion}}

  build_net:
    name: Build
    needs: [version]
    runs-on: windows-latest
    steps:
    - name: Decoding strong-name key
      id: sign_key_file
      uses: timheuer/base64-to-file@v1.2
      with:
        fileName: 'Signature.snk'
        encodedString: ${{secrets.SIGN_ASM_KEY}}
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: true
    - name: Caching NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
    - name: Restore
      run: msbuild ${{env.SolutionName}}.sln /t:Restore
    - name: Build multi-target project
      run: >
        msbuild ${{env.SolutionName}}.sln
        /p:Configuration=Release
        /p:ArtifactsDir="${{github.workspace}}\bin"
        /p:GenerateDocumentationFile=true
        /p:SignAssembly=true
        /p:Version=${{needs.version.outputs.new_version}}
        /p:AssemblyOriginatorKeyFile="${{steps.sign_key_file.outputs.filePath}}"
    - name: Finding portable executables to sign
      id: find_binaries
      run: |
        $filePaths = Get-ChildItem -Path "${{github.workspace}}\bin" -Recurse -Include "${{ env.SolutionName }}.dll" | ForEach-Object { $_.FullName }
        $multiLineString = $filePaths -join "`n"

        echo "Found files to sign:"
        echo $multiLineString

        echo "files_to_sign<<EOF" >> $env:GITHUB_OUTPUT
        echo $multiLineString >> $env:GITHUB_OUTPUT
        echo "EOF" >> $env:GITHUB_OUTPUT
    - name: Signing portable executables
      uses: dlemstra/code-sign-action@v1
      with:
        certificate: '${{secrets.SIGN_PE_CERTIFICATE}}'
        password: '${{secrets.SIGN_PE_PASSWORD}}'
        recursive: false
        files: ${{steps.find_binaries.outputs.files_to_sign}}
    - name: Creating NuGet package
      run: >
        dotnet pack ${{ env.SolutionName }}.sln --no-build --no-restore -o ${{github.workspace}}\nupkg
        /p:ArtifactsDir="${{github.workspace}}\bin"
        /p:PackageVersion=${{needs.version.outputs.new_version}}
        /p:IncludeSymbols=true
        /p:DebugType=Portable
        /p:EmbedUntrackedSources=true
        /p:PublishRepositoryUrl=true
        /p:SymbolPackageFormat=snupkg
    - name: Deploying package to GitHub
      run: dotnet nuget push ${{github.workspace}}\nupkg\ --skip-duplicate --api-key ${{secrets.GITHUB_TOKEN}} --source https://nuget.pkg.github.com/DKorablin/index.json
    # This step query the latest version of SAL Flatbed application to store executable files inside current release
    - name: Get latest Flatbed.Dialog.Lite release version
      id: get_flatbed_release
      run: |
        .\.github\scripts\Download-ReleaseAssets.ps1 -GitHubToken ${{secrets.DEPLOYMENT_TOKEN}} -BinDirectory "${{github.workspace}}\bin"
    # After that we need to extract all files related to SAL executable into bin folder for specific build
    - name: Extract Dependencies and Zip Release Artifacts
      run: |
        # Get all the framework-specific subdirectories in the bin folder
        $frameworkDirs = Get-ChildItem -Path "${{github.workspace}}\bin" -Directory

        foreach ($dir in $frameworkDirs) {
          $frameworkName = $dir.Name
          Write-Host "----- Processing framework: $frameworkName -----"

          # --- Part 1: Organize original build artifacts into a 'Plugin' subfolder ---
          Write-Host "Organizing built artifacts into 'Plugin' subfolder..."
          $pluginFolderPath = Join-Path -Path $dir.FullName -ChildPath "Plugin"
          New-Item -ItemType Directory -Path $pluginFolderPath
          $itemsToMove = Get-ChildItem -Path $dir.FullName -Force
          foreach ($item in $itemsToMove) {
            if ($item.Name -ne "Plugin") {
              Move-Item -Path $item.FullName -Destination $pluginFolderPath
            }
          }

          # --- Part 2: Extract dependency assets into the root of the framework folder ---
          $assetFilename = "Flatbed.Dialog.Lite_${{steps.get_flatbed_release.outputs.latest_version}}_${frameworkName}.zip"
          $assetFilePath = Join-Path -Path "${{github.workspace}}\bin" -ChildPath $assetFilename
          Write-Host "Looking for dependency asset: $assetFilePath"
          if (Test-Path -Path $assetFilePath -PathType Leaf) {
            Write-Host "Asset found. Extracting to '$($dir.FullName)'..."
            Expand-Archive -Path $assetFilePath -DestinationPath $dir.FullName -Force
            Write-Host "Cleaning up downloaded dependency zip..."
            Remove-Item -Path $assetFilePath
          }
          else {
            Write-Error "FATAL: Required dependency asset '$assetFilename' not found."
            exit 1
          }

          # --- Part 3: Create the final zipped release archive ---
          Write-Host "Creating final release archive for $frameworkName..."
          $zipFileName = "${{env.SolutionName}}_v${{needs.version.outputs.new_version}}_${frameworkName}.zip"
          $destinationPath = Join-Path -Path $dir.Parent.FullName -ChildPath $zipFileName
          $sourceContentPath = Join-Path -Path $dir.FullName -ChildPath "*"
          Compress-Archive -Path $sourceContentPath -DestinationPath $destinationPath -Force
          Write-Host "Successfully created release archive: $zipFileName"
          Write-Host "----------------------------------------------------"
        }
    - name: Publish GitHub Release
      uses: ncipollo/release-action@v1
      with:
        artifacts: ${{github.workspace}}\bin\*.zip
        tag: ${{needs.version.outputs.new_tag}}
        name: Auto ${{needs.version.outputs.new_tag}}
        body: ${{needs.version.outputs.changelog}}
        artifactErrorsFailBuild: true
        generateReleaseNotes: true

  failure_cleanup:
    name: Cleanup Tag On Failure
    needs: [version, build_net]
    if: always() && needs.build_net.result != 'success'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: false
        fetch-depth: 0 #Fetch all history for all tags and branches
    - name: Removing version tag
      run: |
        git tag -d ${{needs.version.outputs.new_tag}} || true
        git push origin :refs/tags/${{needs.version.outputs.new_tag}} || true