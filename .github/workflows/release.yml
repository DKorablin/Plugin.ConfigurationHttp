# This GitHub Actions workflow automates the entire CI/CD process for a .NET solution
# that contains both a .NET Framework and .NET projects.
#
# Workflow Steps:
# 1. Test: Runs unit tests for the solution.
# 2. Version: Automatically increments the version number and creates a new git tag.
# 3. Detect & Build: Detects the project types by using Target Framework from csproj files (.NET Framework vs .NET)
#    and builds them separately using the appropriate tools (MSBuild or dotnet CLI).
# 4. Deploy Release:
#    - Moved release asset into Plugin folder to separate SAL Host and release assets.
#    - Downloads latest release assets from a corresponding "Flatbed.Dialog.Lite" version repository.
#    - Merges the downloaded assets into the build output.
#    - Creates two separate zip archives for each framework type.
#    - Publishes a single GitHub Release containing both zip files.
# 5. Deploy NuGet: Publishes a NuGet package to GitHub Packages.
# 6. Cleanup: If any build or deploy step fails, it automatically removes the created git tag.

name: Test, Buid, Release

on:
  push:
    branches: [ "master" ]
  workflow_dispatch:

env:
  SolutionName: ${{github.event.repository.name}}
  NuGetPackageSourceCredentials_github_DKorablin: Username=${{github.actor}};Password=${{secrets.DEPLOYMENT_TOKEN}}
  DotNetVersion: 8.0.x

jobs:
  test_net_windows:
    name: Testing .NET (Windows)
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: true
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{env.DotNetVersion}}
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        # Create a new cache when packages.lock.json changes
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
        # If the exact key doesn't exist, use the most recent cache for this OS
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restoring dependencies
      run: dotnet restore ${{env.SolutionName}}.sln
    - name: Testing .NET
      run: dotnet test ${{env.SolutionName}}.sln --no-build --verbosity normal

  version:
    name: Incrementing version number
    needs: [test_net_windows]
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{steps.tag_version.outputs.new_version}}
      new_tag: ${{steps.tag_version.outputs.new_tag}}
      changelog: ${{steps.tag_version.outputs.changelog}}
    steps:
    - name: Updating version number
      id: tag_version
      uses: mathieudutour/github-tag-action@v6.2
      with:
        github_token: ${{secrets.GITHUB_TOKEN}}
        #custom_tag: 1.0.0

  build_net:
    name: Build
    needs: [version]
    runs-on: windows-latest
    steps:
    - name: Decoding strong-name key
      id: sign_key_file
      uses: timheuer/base64-to-file@v1.2
      with:
        fileName: 'Signature.snk'
        encodedString: ${{secrets.SIGN_ASM_KEY}}
    - uses: actions/checkout@v4
 
      with:
        dotnet-version: ${{env.DotNetVersion}}
    - name: Caching NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
    - name: Restore
      run: msbuild ${{env.SolutionName}}.sln /t:Restore
    - name: Build multi-target project
      run: >
        msbuild ${{env.SolutionName}}.sln
        /p:Configuration=Release
        /p:ArtifactsDir="${{github.workspace}}\bin"
        /p:GenerateDocumentationFile=true
        /p:SignAssembly=true
        /p:Version=${{needs.version.outputs.new_version}}
        /p:AssemblyOriginatorKeyFile="${{steps.sign_key_file.outputs.filePath}}"
    - name: Listing output directory
      run: |
        echo "Listing files in the release directory:"
        ls ${{github.workspace}}\bin -Recurse
      shell: pwsh
    - name: Finding portable executables to sign
      id: find_binaries
      run: |
        $filePaths = Get-ChildItem -Path "${{github.workspace}}\bin" -Recurse -Include "${{ env.SolutionName }}.dll" | ForEach-Object { $_.FullName }
        $multiLineString = $filePaths -join "`n"

        echo "Found files to sign:"
        echo $multiLineString

        echo "files_to_sign<<EOF" >> $env:GITHUB_OUTPUT
        echo $multiLineString >> $env:GITHUB_OUTPUT
        echo "EOF" >> $env:GITHUB_OUTPUT
      shell: pwsh
    - name: Signing portable executables
      uses: dlemstra/code-sign-action@v1
      with:
        certificate: '${{secrets.SIGN_PE_CERTIFICATE}}'
        password: '${{secrets.SIGN_PE_PASSWORD}}'
        recursive: false
        files: ${{steps.find_binaries.outputs.files_to_sign}}
    - name: Creating NuGet package
      run: |
        dotnet pack ${{ env.SolutionName }}.sln --no-build --no-restore -o ${{github.workspace}}\bin\nupkg /p:PackageVersion=${{ needs.version.outputs.new_version }} /p:IncludeSymbols=true /p:DebugType=Portable /p:EmbedUntrackedSources=true /p:PublishRepositoryUrl=true /p:SymbolPackageFormat=snupkg
    - name: Deploying package to GitHub
      run: dotnet nuget push ${{github.workspace}}\bin\nupkg\ --skip-duplicate --api-key ${{secrets.GITHUB_TOKEN}} --source https://nuget.pkg.github.com/DKorablin/index.json
    - name: Deploying artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{needs.detect_frameworks.outputs.net_version}}
        path: ${{github.workspace}}\bin\*
        if-no-files-found: error

  deploy_release:
    name: Deploying release
    needs: [version, build_net]
    runs-on: ubuntu-latest
    steps:
    - name: Extracting all artifacts
      uses: actions/download-artifact@v4
      with:
        path: bin
    - name: Organize Artifacts into Plugin subfolders
      # This step creates a "Plugin" folder inside each artifact directory and moves all content into it.
      run: |
        cd ${{github.workspace}}/bin
        for dir in */; do
          dir_name="${dir%/}"
          mkdir "$dir_name/Plugin"
          # Use a subshell and a for loop for a more compatible way to move files.
          (
            cd "$dir_name"
            shopt -s dotglob
            for item in *; do
              if [[ "$item" != "Plugin" ]]; then
                mv -- "$item" "Plugin/"
              fi
            done
          )
        done
    # This step query the latest version of SAL Flatbed application to store executable files inside current release
    - name: Get latest Flatbed.Dialog.Lite release version
      id: get_flatbed_release
      run: |
        LATEST_VERSION=$(curl -s -H "Authorization: token ${{secrets.DEPLOYMENT_TOKEN}}" "https://api.github.com/repos/DKorablin/Flatbed.Dialog.Lite/releases/latest" | jq -r .tag_name)
        if [ "$LATEST_VERSION" = "null" ] || [ -z "$LATEST_VERSION" ]; then
          echo "Error: Could not find the latest release for DKorablin/Flatbed.Dialog.Lite."
          exit 1
        else
          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
        fi
    - name: Downloading Flatbed.Dialog.Lite latest versions
      uses: dsaltares/fetch-gh-release-asset@master
      with:
        repo: DKorablin/Flatbed.Dialog.Lite
        regex: true
        file: Flatbed.Dialog.Lite.*.zip
        token: ${{secrets.DEPLOYMENT_TOKEN}}
    # After that we need to extract all files related to SAL executable into bin folder for specific build
    - name: Dynamically extract assets into framework folders
      shell: bash
      run: |
        # Change to the directory containing the build output framework folders
        cd ${{github.workspace}}/bin
        
        # Loop through each framework directory (e.g., net48/, net8.0-windows/)
        for dir in */; do
          FRAMEWORK="${dir%/}" # Get the directory name without the trailing slash
          echo "-----> Processing framework: $FRAMEWORK"
          
          # Construct the expected asset filename based on the framework
          ASSET_FILENAME="Flatbed.Dialog.Lite_${{ steps.get_flatbed_release.outputs.latest_version }}_${FRAMEWORK}.zip"
          ASSET_FILE_PATH="${{github.workspace}}/$ASSET_FILENAME"
          
          echo "Looking for asset file: $ASSET_FILE_PATH"
          
          # Check if the corresponding zip file was downloaded
          if [ -f "$ASSET_FILE_PATH" ]; then
            echo "Asset found. Extracting to './$dir'..."
            # Unzip the asset into its corresponding framework folder
            unzip -o "$ASSET_FILE_PATH" -d "$dir"
            
            echo "Cleaning up downloaded zip file..."
            rm "$ASSET_FILE_PATH"
          else
            echo "::warning::Asset file '$ASSET_FILENAME' not found. Skipping extraction for this framework."
          fi
          echo "-----> Finished processing framework: $FRAMEWORK"
        done
    # After SAL executables are also packed inside bin folder we need to pack all of them into separate release assets
    - name: Zipping individual artifacts
      run: |
        # Packing each subdirectory into different release asset
        cd ${{github.workspace}}/bin
        for dir in */; do
          dir_name="${dir%/}"
          (cd "$dir_name" && zip -qq -r "../${{env.SolutionName}}_v${{needs.version.outputs.new_version}}_${dir_name}.zip" .)
        done
      working-directory: ${{github.workspace}}/bin
    - name: Deploying GitHub release
      uses: ncipollo/release-action@v1
      with:
        # Creating deployment release with from all packed zip files
        artifacts: ${{github.workspace}}/bin/*.zip
        tag: ${{needs.version.outputs.new_tag}}
        name: Auto ${{needs.version.outputs.new_tag}}
        body: ${{needs.version.outputs.changelog}}
        artifactErrorsFailBuild: true
        generateReleaseNotes: true
        token: ${{secrets.DEPLOYMENT_TOKEN}}

  failure_cleanup:
    name: Remove version tag on failure
    needs: [version, build_net]
    if: always() && needs.build_net.result != 'success'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: false
        fetch-depth: 0 #Fetch all history for all tags and branches
    - name: Removing version tag
      run: |
        git tag -d ${{needs.version.outputs.new_tag}} || true
        git push origin :refs/tags/${{needs.version.outputs.new_tag}} || true